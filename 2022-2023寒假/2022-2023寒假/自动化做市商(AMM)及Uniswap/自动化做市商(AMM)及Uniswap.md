# 自动化做市商(AMM)及Uniswap
## 什么是自动化做市商
AMM又称自动化做市商，它是去中心化交易所（DEX）最为关键的技术之一，已被证明是最具影响力的DeFi创新之一，它们能够为一系列不同代币创建和运行可公开获取的链上流动性。
在展开论述前，我们先认识几个名词。
**AMM(Automated Market Maker) 自动做市商
Liquidity 流动性，指各项资产的数量分布情况
Liquidity Pool 流动性池，指各类资产所对应的资金池
LP(Liquidity Provider) 流动性提供者，向流动性池内添加对应资产的用户
Order Book 订单薄，中心化交易所的做市方式
Slippage 滑点，指下单价格和最后成交价的差额比例**
传统的中心化交易所上的订单薄做市模式在区块链上运作起来出现了很多问题，所以就创新了AMM自动做市商。
## 中心化交易所做市模式
在传统的交易所中做市，不管是股市还是加密资产交易所，采用的都是订单薄模式。订单薄记录着买卖双方对资产的报价情况。在Order Book中有两个角色，第一个是做市商，即挂单者，也叫Maker；另一个是交易者，即吃单者，也叫Taker。
专业的做市商（Maker）会同时在交易所的买卖两个方向挂单，并且根据市场的波动性调整报价，为交易所提供流动性。简单来说做市商就是提供报价和流动性的人。
在做市行为中，挂单的资产数量称为流动性，提供资产的人称为流动性提供者。LP提供流动性后，还需要为资产提供一个价格，这样才算是完成做市。通常情况下，流动性与价格的提供者都是同一个人。如果一个交易所没有做市商做市，或者很少做市商，交易者想要交易就会面临没有流动性的情况。缺乏流动性就意味着会造成高滑点交易，即交易者最终成交价格与看到的价格有很大差距，这会导致整个市场交易积极性不高。为了提高交易的流动性，中心化交易所通常会吸引做市商来进行做市操作。
专业的做市商会在当前价格附近提供尽可能多的流动性，以供交易者交易，然后以非常高的频率进行撤单和挂单操作，以避免产生损失。做市商最终目的是获利，与此同时他们的交易活动也为交易者创造了流动性，降低了交易滑点。许多做市商都是专业的团队或者机构，他们拥有充足的资金和强大的技术支持，对市场敏感度高，可以实时对做市策略进行调整，以避免损失。
在中心化交易所做市除了有一定难度和门槛问题外，中心化交易所还一手掌管着用户的资产和数据存储，不仅会暴露个人隐私，交易和代币的流通也存在不够透明的问题。
## 自动做市商模式
这里用最经典的AMM——uniswap来举一个例子。
假设我们在 Uniswap 的某个池里投入 50 个苹果 （a） 和 50 个香蕉 （b） ，任何人都可以用苹果换香蕉，或者用香蕉换苹果。假设一级市场中苹果与香蕉的**汇率刚好是 1:1**。因为该 Uniswap 资金池中分别有 50 个苹果和 50 个香蕉，因此，按上述常数积的等式规则，a * b = 2500 。对于任何交易，Uniswap 都需要保证，池中库存的苹果数和香蕉数相乘等于 2500。好了，假设一位客户进入我们的 Uniswap 池来买一个苹果。她应该支付多少个香蕉呢？如果她买走一个苹果，我们的池里就剩下 49 个苹果，而 49* b 依然需要等于 2500。这样香蕉的总数 b 就等于51.02。由于之前池中有 50 个香蕉，因此我们**还需要 1.02 个香蕉**（在这个宇宙中我们允许碎片化香蕉的存在） ，因此，这位客户买一个苹果会得到的报价是：1.02 香蕉 / 苹果。
## AMM模式的优点和不足
AMM的自动化模式使得做市操作变得非常简单，并且在去中心化的背景下其监管面非常小，提供流动性也很便捷，任何用户都可以以任何资金量参与。流动性挖矿奖励也激励了用户提供流动性，提供良好的闭环。
不过，AMM模型也没有达到完美程度。它存在一些局限性，体现在三方面：
**第一， 无常损失的风险。** 在AMM中，LP面临最多的就是无常损失。当场外价格和流动池内对应代币的价格往任何方向偏离时，就会产生这种损失。AMM中的流动池不会自动感应到场外价格，当流动池中代币的价格偏离正常市场价格时，就需要套利者这个角色帮助让价格逐渐回归正常。套利者在资金池内赚取差价，而这个利润就是从LP资金中抽离的，因此会对用户资金造成一定损失。只要AMM中的代币当前价格恢复到LP存入时的原始值，这种损失就会消失，但这种情况很少见。
**第二， 资本效率低。** 从恒定乘积做市商的量价模型函数来看，LP提供的流动性均匀分布在价格（0-∞）的曲线上。只有当定价曲线变化区间很大时，流动资金的很大一部分才可以交易流通，这可以称为被动做市。被动做市的缺点是当交易活跃时，当前价格附近的流动性很快会枯竭，同时伴随滑点升高，价格快速发生较大偏离，导致交易停止，这样使得流动性池的资金使用率不高，这是现在大部分DEX的现状。Uniswap3在引入主动做市协议，希望解决这一问题，但似乎并不是很智能。
**第三， 多代币敞口的风险。** 作为LP需要购买另一种资产以提供流动性，这将增加对另一资产的敞口，意味着要承受多重代币价格浮动的风险。
# 什么是Uniswap？
uniswap是一个进行**自动化做市商**的项目，该项目的特点是公平，去中心，抗审查，安全。并且uniswap并不会存在特殊群体，参与项目的每个人都是平等的不论你是LP还是Trader。
V1的特点：

- 支持不同的ERC20token进行交换
- 可以加入流动矿池成为LP并获取奖励费用
- 利用公式进行自动定价，每次交易过后都会进行计算定价
- 支持私人定制的交换

每个LP按照一定比例输入ERC20-ERC20的数量之后，会获得一定数量LPtoken，用来表示贡献度，可以根据贡献度来领取池中的奖励（奖励的来源为每次交易收取的费用）。如果想退出的话，可以将LPtoken进行销毁，销毁后会按照LPtoken的比例将两种资金进行返回。

同时可以设置限价单和限时单。
## Uniswap如何进行计算
### 无交易费推导
在整个计算过程中**uniswap使用的是x-y-k的模型**，即为无论怎样进行交易，保持交易后**x * y = k**，两种代币的乘积不变。根据这个思想，进行推导

设要用**Δx**数量的x代币交换**Δy**代币,则有

```
(x + Δx) * (y - Δy) = k = x * y
设 α = Δx / x, β = Δy / y，将其代入上式可得
∴ (x + α * x) * (y - β * y) = x * y
∴ (1 + α) * (1 - β) = 1
∴ α = β / (1 - β), β = α / (1 + α)
∴ Δy = α / (1 + α) * y = Δx / (x + Δx) * y
  Δx = β / (1 - β) * x = Δy / (y - Δy) * x
```
### 带手续费交易
在实际情况中，**每一次交易都会收取一定的手续费用来交易LP**，通常**手续费为交易量的0.3%**，这就表明你输入的Δx并不是全用于计算，实际的计算值为**Δx * 0.97%**，剩下的作为手续费放入交易池中奖励LP，下面是实际的推导过程： 设要用Δx数量的x代币交换Δy代币,则有

```
设手续费的比例为ρ, 1 - ρ为γ
(x + Δx * γ) * (y - Δy) = k = x * y
设 α = Δx / x, β = Δy / y，将其代入上式可得
∴ (x + α * x * γ) * (y - β * y) = x * y
∴ (1 + α * γ) * (1 - β) = 1
∴ α = β / ((1 - β) * γ), β = (α * γ) / (1 + α * γ)
∴ Δy = α * γ / (1 + α * γ) * y = (Δx * γ) / (x + Δx * γ) * y
  Δx = β / (1 - β) * x = Δy / (y - Δy) * (1 / γ) * x
//我们假设ρ = 0.3%，所以γ = 997 / 1000
∴ 上述结果可以表示为：
  Δy = (997 * Δx * y) / (1000 * x + 997 * Δx)
  Δx = (1000 * Δy * x) / ((y - Δy) * 997))
```
通过上面推导可以看出当**ρ为0时就成为了无手续费模式**，并且可以发现一个问题，**代入手续费之后整个池子的k只会略微变大**，这是因为会有**部分的费用作为手续费进入池子并不会进入交易当中**。也可以理解为，你输入的**Δx = 手续费 + 实际的交易的数量**

在实际的交易中，会出现以下两种情况：

**给出交易的x代币数量，计算出y代币的数量**
在这种情况下，输入的x代币会有一部分作为手续费放入池中，其余部分才会被用来做交换。计算时可参考上面手续费交易的结果。
**给出想要的y代币数量，计算出所需要的x代币数量**
给出想要获取的y代币，计算所需的x代币数量，同时x代币中包含了手续费和实际交换数量。计算时可参考上面手续费交易的结果。
### 流动性计算
用户不仅可以进行代币的交换，同时还可以成为**LP(Liquidity provider)**，获取LPtoken用来获取池子中的利息。流动性计算的推导如下

```
设l = x * y表示两种代币的数量，则有
//提供流动性推导
设α = Δx / x，则有
∴ Δy = Δx / x * y + 1
  Δl = Δx / x * y
∴ x' = x + Δx
  y' = y + Δx * t / x + 1 //这是考虑到solidity语法在计算时的小数会进行向下取整
  l' = l + Δx * l / x

//取消流动性
设β = Δl / l
∴ Δx = Δl * x / l
  Δy = Δl * y / l
∴ x' = x - Δx
  y' = y - Δy
  l' = l - Δl
```
由于存在向下取整的计算方式，我们将提供和取消两种结合起来看之后会发现，在取消之后剩余的x，y的数量大于提供流动性之前，这是为了保证避免投资者通过这种方式进行获利。如果不使用向下取整的计算方式的话，其实提供和取消之后x，y的数量不会发生变化。同时在提供流动性之后，LP会获取LPtoken，**LPtoken数量等于两种代币之积(代币数量更新之后)再开根号**。

### 滑点问题
由于Uniswap是在区块链上的操作，所以可能会导致你看到的价格和实际的价格会有所不同，这是由于交易的确认需要时间，并且交易的顺序不清楚。这样就会导致产生交易滑点，通常为0.5%的滑点保护。而对于滑点的计算我们**通常使用(实际成交价格 - 交易时输入的价格) / 交易时输入的价格**。当计算出的值满足设定的比例时，即可完成交易。

### 流动性挖矿问题
由于在每笔交易时都会收取一定的手续费，这些手续费会按照LP的持有的token的比例进行分发。这是为了激励用户成为LP并且投入更多的资金，创造更多的流动性。
### 手续费问题
由于在每笔交易时都会收取一定的手续费，**这些手续费会按照LP的持有的token的比例进行分发**。这是为了激励用户成为LP并且投入更多的资金，创造更多的流动性。从理论上来说当每一一笔交易发生的时候要将手续费分发给LP，在进行分发的时候可能会使用一个大循环进行分配。但是在**实际中这样对用户消耗的gas是很多的**，所以这样的方法是不可行的。所以在代**码中将手续费的分配放在LP提供流动性和移除流动性的部分**，并且维持**手续费公平分配**的与那里很简单。**每次用户进行交易的时候交易的手续费会将每单位的LPtoken的代币的价值提高，而LP在提供流动性的时候会按照当前每单位的LPtoken的代币的价值进行买入LPtoken（变相地理解）**，举例说明：用户A提供流动性的时候获取了100LPtoken，池子中有1000tokenA，1000tokenB，这时候1LPtoken的价值分别是10tokenA和10tokenB，在经过多次买卖后池子里面有1100tokenA和1500tokenB，这时候1LPtoken对应11tokenA和15tokenB，多出来的这部分即为手续费收益。当用户B想要增加流动性的时候，会按照1LPtoken对应11tokenA和15tokenB的比例进行生成LPtoken，然后按照上面所说的再进行手续费的收益。

### 质押性挖矿
质押挖矿，在项目中**LP可以通过质押自己的LPtoken通过质押一定的时间可以获取质押合约中的奖励代币**。再uniswap中LP可以质押自己的LPtoken去获取UNI代币，获取的UNI代币可以去交易所兑换其他的代币，也可以用于参与uniswap的治理，可以通过持有的UNI数量进行投票。

### 质押挖矿的算法推导
在质押挖矿合约中会进行规定每经过一段时间就会生成一定数量的奖励代币，并且将这些奖励代币按照LP质押的token的数量进行分配给LP。正常思路下我们在分配的时候，会采用循环将质押的用户进行遍历分配。但是在智能合约中使用循环便利的话会消耗大量的gas，这样是不明智的。所以我们要换一种思路来进行奖励的分配。

```
我们假设质押合约中每秒的奖励为R，合约中质押的代币总数为T，用户A的质押代币数量为a，T包含a
∴ 每秒每一代币的奖励数量为R / T， 用户A每秒获取的代币数量为 a * R / T
我们假设用户A在6秒后取出质押的代币
∴ A所获得的奖励代币数量为：a * R / T * 6

我们再假设B用户在A用户质押4秒后质押了b数量的代币
∴ A所获得的奖励代币数量为：
  a * R / T * 4 + a * R / (T + b) * 2 = a * (R / T + R / T + R / T + R / T + R / (T + b) + R / (T + b))

按照这种思路，我们再进行假设
假设质押的总时长为6秒，A用户在第2秒质押a数量代币，B用户在第4秒质押b数量代币，A用户质押前的代币总数为T'
∴ A所获得的奖励代币数量为：
  a * R / T * 2 + a * R / (T + b) * 2 = a * (R / T + R / T + R / (T + b) + R / (T + b)) = a * (R / T' + R / T' + R / T + R / T + R / (T + b) + R / (T + b)) - a  * (R / T' + R / T')
```
通过最终的推导式，我们可以得到用户A获得的**奖励代币数量等于结算时的累计每份质押代币对应的奖励代币数量之和减去加入时累计每份质押代币对应的奖励代币数量之和再乘以A代币的数量**。这样计算的前提是**用户A的质押代币的数量不会进行更改**，那么问题来了，如果用户对质押代币的数量进行更改了，如何进行计算呢？
其实解决方法很简单，在每次更改数量的时候，对先前数量的质押代币获取的奖励进行结算，然后将变换后的质押代币数量重新进行上述的数量不变的推导。这就是uniswap质押合约代码的逻辑结构，详细的代码可以参考[https://github.com/Uniswap/liquidity-staker](https://github.com/Uniswap/liquidity-staker)

### 问题
质押挖矿的算法推导是不存在问题的，但是在使用时要结合实际情况来进行考虑。由于**solidity中对于除法计算使用的是向下取整**，所以在上述推导公式中对于**每份质押代币对应的奖励代币数量**的计算可能会出现结果为0的情况，虽然uniswap的代码中将每秒奖励的数量扩大10*18倍，但是还要考虑扩大之后如果还是小于总的质押代币数量，这个时候可能会出现用户在这段时间的收益为0的情况。这是由于语言特性产生的bug问题。
也要考虑额质押代币数量为0的情况，此时计算收益会出现问题。