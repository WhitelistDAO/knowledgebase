# [计]{.underline} [算属性]{.underline} 

> 当模板中需要多次相同逻辑计算时，我们没必要在模板中将代码重复几遍，根据官方文档推荐，我们可
> 以使用计算属性来描述依赖响应式状态的复杂逻辑，例子：

+----------------+----+-----------------------------------------------+
| books:         | \[ | \- Advanced Guide\',                          |
|                |    |                                               |
| \'Vue          | 2  |                                               |
+================+====+===============================================+
| \'Vue          | 3  | \- Basic Guide\',                             |
+----------------+----+-----------------------------------------------+
| \'Vue          | 4  | \- The Mystery\'                              |
+----------------+----+-----------------------------------------------+

> author.books.length \> 0 ? \'Yes\' : \'No\' 是一个三目运算符：\[...\]
> ? a : b
> ,\[\]里面是二元运算符，当结果是true时，返回a；当结果时false时，返回b。
>
> reactive()创建响应式对象author，定义一个计算属性publishedBooksMessage，computed()方法用来
> 接收一个getter函数，返回值为一个计算属性ref。
>
> vue使用计算属性的一个好处就是vue的计算属性会自动追踪响应式依赖，如上例子，它会检测到publishedBooksMessage依赖于author.books，当author.books发生改变时任何绑定于
>
> publishedBooksMessage都会同步更新。
>
> 而计算属性相比于方法的不同之处在于计算属性值会基于响应式依赖被缓存，只要author.books不改变，无论访问多少次publishedBooksMessage都会直接返回先前的计算结果，不用重复执行getter函
> 数。
>
> 计算属性默认为只读，当想用可写属性时，可以手动提供getter和setter来创建：
>
> [**条**]{.underline}

## v-if

**[件渲染]{.underline}**

> 用于条件性地渲染，只有当表达式为真值时才会被渲染

## v-else

> 一个

## v-else-if

> 元素必须跟在一个 或者
>
> 元素后面，否则它将不会被识别。
>
> 和

## v-show

> 类似，一个使用
>
> 的元素必须紧跟在一个
>
> 或一个
>
> 元素后面。
>
> 用法和v-if 相似，不同的是v-show
> 会在DOM渲染中保留该元素，并且不能用于\<template\>标签
>
> 总的来说， v-if 有更高的切换开销，而
> 有更高的初始渲染开销。因此，如果需要频繁切换，
>
> 则使用
>
> 较好；如果在运行时绑定条件很少改变，则
>
> 会更合适。

# [列]{.underline} [表渲染]{.underline} 

## v-for

> 例子；
>
> 这里是基于数组来渲染一个列表， v-for 指令的值需要使用
> 形式的特殊语法，其中
>
> 是源数据的数组，而 是迭代项的别名
>
> ![](media/image1.png){width="0.14590004374453194in"
> height="0.13547790901137358in"}![](media/image2.png){width="0.2501159230096238in"
> height="0.13547790901137358in"}v-for 可以和v-if
> 组合使用，但不是在同一个标签里面使用，否则会因为v-if
> 优先级更高无法访问v- for 作用域定义的变量别名

# [事]{.underline} [件处理]{.underline} 

## v-on

> 使用v-on 监听事件（简写@）用法： v-on:click=\"methodName\" 或

## 内联事件处理器：

> counter++是内联语句，也就是说内联事件处理器用v-on 监听事件然后"
> "里面用内联语句组成内联事件处理器
>
> 在内联处理器中可以调用方法，这允许我们向方法传入自定义参数以代替原生事件：
>
> 可以向该处理器方法传入一个特殊的件参数：
>
> 变量，或者使用内联箭头函数在内联事件处理器中访问事

## 方法事件处理器：

> v-on
> 通过接受一个方法名或者对方法的调用，称为方法事件处理器，使用方法处理器的好处就是当事件逻辑越来越复杂的时候，内联事件处理器就显得过于笨重，不够优雅，此时方法事件处理器就可以更灵
> 活的处理事件。
>
> 方法事件处理器会自动接收原生 DOM
> 事件并触发执行。在上面的例子中，我们能够通过被触发事件的访问到该 DOM
> 元素。

## 事件修饰符：

> ![](media/image3.png)Vue 为
> 提供了**事件修饰符**，以便不用在方法中调用例如event.preventDefault()（阻止事件的默认
>
> 行为）之类的去处理DOM事件细节，让我们更专注于数据逻辑。修饰符是用以下这些：
>
> 表示的指令后缀，包含
>
> .capture 、.once 和
>
> 修饰符与原生
>
> 事件相对应：
>
> 修饰符一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能

## 按键修饰符

> 需要监听键盘事件时，可以通过@keyup 来实现：

+-----------+----------------------------------------------------------+
| >         | **实际键值**                                             |
|  **别名** |                                                          |
+===========+==========================================================+
| > .delete | delete（删除）/BackSpace（退格）                         |
+-----------+----------------------------------------------------------+
| > .tab    | Tab                                                      |
+-----------+----------------------------------------------------------+
| > .enter  | Enter（回车）                                            |
+-----------+----------------------------------------------------------+
| > .esc    | Esc（退出）                                              |
+-----------+----------------------------------------------------------+
| > .space  | Space（空格键）                                          |
+-----------+----------------------------------------------------------+
| > .left   | Left（左箭头）                                           |
+-----------+----------------------------------------------------------+
| > .up     | Up（上箭头）                                             |
+-----------+----------------------------------------------------------+
| > .right  | Right（右箭头）                                          |
+-----------+----------------------------------------------------------+
| > .down   | Down（下箭头）                                           |
+-----------+----------------------------------------------------------+
| > .ctrl   | Ctrl                                                     |
+-----------+----------------------------------------------------------+
| > .alt    | Alt                                                      |
+-----------+----------------------------------------------------------+
| > .shift  | Shift                                                    |
+-----------+----------------------------------------------------------+
| > .meta   | (window系统下是window键，mac下是command键)               |
+-----------+----------------------------------------------------------+

> vue支持组合写法：
>
> .exact **修饰符**
>
> 修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。

# [表]{.underline} [单输入]{.underline} 

> v-modle
> 将表单输入框的内容同步给js中相应的变量（之前提到的双向绑定就是通过这个原理）
>
> v-modle 支持各种不同类型的input、\<textare\>、\<select\>元素例如：
>
> 这是一个基础的v-modle
> 文本语法，\<textare\>、\<select\>用法类似，但注意在 中是不支
>
> 持插值表达式的。请使用 来替代：
>
> ![](media/image1.png)**对于单选按钮、复选框和选择器选项，**
> v**-**modle **通常绑定的值是静态的字符串**，因此可以通过使用
>
> 来实现将该值绑定到当前组件实例上的动态数据。此外，使用字符串的数据类型：
>
> 还可以将选项值绑定为非
>
> **vue复选框有两个特有属性：** true**-**value **和**

##  ，仅支持和

> **配套使用**：
>
> 这里toggle的值被选中时设为"yes"，取消选择时是"no"。这两个属性搭配上
> v-bind 可以实现绑定动态值

## 一些修饰符

> （拓展）：
>
> 文本类型的
>
> 事件；
>
> 会绑定
>
> 和 \<textarea\> 元素会绑定和
>
> property 并侦听
>
> property 并侦听会绑定
>
> 事件。
>
> 事件；
>
> property 并侦听
>
> **.lazy**：默认情况下， v-model 会在每次事件后更新数据：
>
> 事件后更新数据。可以添加
>
> 修饰符来改为在每次
>
> **.number**：让用户的输入自动转换为数字（当输入框type="number"时自动生效）
>
> **.trim**:默认自动除去用户输入内容中两端的空格

# [生]{.underline} [命周期]{.underline} 

> 以下是文档提供的生命周期的图表（详细可以参考vue3.js的[[API]{.underline}](https://cn.vuejs.org/api/)部分）：
>
> ![](media/image4.png){width="6.196444663167104in"
> height="9.801457786526685in"}

# [侦]{.underline} [听器]{.underline} 

> 基本示例：
>
> 该示例使用watch函数 在每次响应式状态发生改变时触发回调函数。 watch
> 的第一个参数可以是不同形式的"数据源"：**它可以是一个 ref
> (包括计算属性)、一个响应式对象、一个 getter
> 函数、或多个数据源组成的数组**
>
> watch
> **函数是懒执行，只有当数据源发生变化时才执行回调函数**，当想要创建侦听器时立马执行一遍回调函数，可以使用watchEffect()
> ， watchEffect()
> **会立即执行一遍回调函数，如果这时函数产生了副作用，Vue
> 会自动追踪副作用的依赖关系，自动分析出响应源**。
>
> 这是没使用watchEffect() 函数：
>
> 这是使用watchEffect() ：
>
> 可以很明显的看出使用watchEffect() 要简洁不少。
>
> ps：想要使用深层监听，可以设置deep：true
>
> **总结一下** watch() **和** watchEffect() **区别**：
>
> 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确
> 实改变时才会触发回调。 watch
> 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。
>
> watchEffect
> ，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问
>
> 到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。

## 回调的触发时机

> 设置flush: \'post\'
> ，在侦听器回调中访问更新之后的DOM，因为默认情况下创建的侦听器回调都会在组件更新之前被调用

## 停止侦听器

> 在 或
>
> 中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会
>
> 在宿主组件卸载时自动停止。
>
> 一个关键点是，侦听器必须用**同步**语句创建：如果用异步回调创建一个侦听器，那么它不会绑定到当前
> 组件上，你必须手动停止它，以防内存泄漏。如下方这个例子：
>
> 要手动停止一个侦听器，将停止：
>
> 或 watchEffect 函数赋给一个变量，然后调用便可以在达到条件时

## 模板引用

> 当需要直接访问底层DOM元素时，可以使用ref 属性实现：
>
> 使用组合式API获得模板引用，应该声明同名的ref
>
> 如果不是使用\<script setup\>，需要确保从 setup() 返回ref：
>
> 当在 中使用模板引用时，对应的 ref
> 中包含的值是一个数组，它将在元素被挂载后包含对应整个
>
> 列表的所有元素：
>
> 注：此用法需要v3.2.25及以上版本

# [组]{.underline} [件基础]{.underline} 

> 组件树：

## 定义一个组件

> 当使用构建步骤时，我们一般会将 Vue 组件定义在一个单独的称 SFC)：
>
> 文件中，这被叫做[单文件组件](https://cn.vuejs.org/guide/scaling-up/sfc.html)
> (简

## 使用组件

> 要使用一个子组件，我们需要在父组件中导入它。假设我们把计数器组件放在了一个叫做
> 的文件中，这个组件将会以默认导出的形式被暴露给外部。
>
> 通过 \<script setup\>
> ，导入的组件都在模板中直接可用。组件可以被任意调用多次，每个组件维护自己的状态，没有相互影响

## 传递（props）

> 向组件中传递数据使用props 在顶层属性中使用：
>
> 如果你没有使用 \<script setup\> ，props 必须以函数的第一个参数被传入：
>
> 选项的方式声明，props 对象会作为

## 是一个仅 中可用的编译宏命令，并不需要显式地导入。声明的

> props 会自动暴露给模板。 defineProps
> **会返回一个对象，其中包含了可以传递给组件的所有**

## props：

> **监听事件**（示例代码：[Blog[Post]{.underline}](https://sfc.vuejs.org/%23eNp9Uk1v2zAM/SuEMMApFlvLtpPhBN2A7jagwIDtUO%2BQOLSj1JYESU7nGf7vo/wRp2tTn8z3Hh8pki37onV0qpHFLLGZEdqBRVfrTSpFpZVx0ILBHDrIjaogIGlwpr6WqrhX1o1cxCfAO5IMIJWZkiTQBFpYe6vFgydaEPsYVktwwpUYQ/C9gaOqjcQGnoQ7wE9ygG45az/OWl%2BmELK4ovw0K38dGs%2BDsGAV5LUkZSp/36TysrNvSrof4i%2BODa6ITvgwDZoDBQ4rXW4d%2Bsgle3GC2LqmxHXKWsjH7Pi513sIsPLlGGUBfck0nSEEOIW5MmTh00DIYUgpm%2Bj4EZuRjcT%2BAu8fNzF9MJO3KMutKTB0%2BMeNmrmlNXyIVpN4k5z31XeYcHoY/SX8/Fy2ZMOqw2qro6NVku6k7Rc7EtRvDD3iMVq7j1N2cE7bmHObZ/4WjjZSpuD0F5laOlFhhLYKd0Y9WTRknLJ%2Bf6MHJ/CEJjQo92jQvOX5n/SFr7ellXf0lMvrfOXe95gLifdGabt4CPq5Bv5SBvyuEs7jl/Pt6auXQhP1l5KVW2tpEzuqHvp1zAdx%2BLxp2%2BFWoesSTvHI7GrnlITbrBTZIyW/Qyq/eF78hozuBgA8kPAh6%2Boyu3%2B/5lNs)）
>
> ![](media/image5.png)父组件可以通过 或
> 来选择性地监听子组件上抛的事件，就像监听原生 DOM 事件那样：
>
> 子组件可以通过调用内置的 方法，通过传入事件名称来抛出一个事件：
>
> 我们可以通过 defineEmits 宏来声明需要抛出的事件：
>
> 和 类似， defineEmits 仅可用于 之中，并且不需要导入，它返回一
>
> 个等同于
>
> 方法的
>
> 函数。
>
> 它可以被用于在组件的 中抛出事件，因为此处无法直接访问 \$emit ：
>
> 不使用\<script setup\>，可以通过 emits
> 选项自定义组件抛出的事件，可以从 函数的第二个参
>
> 数，即 setup 上下文对象上访问到 函数：

## 通过插槽分配内容

> 想和HTML元素一样向组件中传递内容，可以通过vue自定义的\<slot\>元素来实现
>
> 如上，使用 作为一个占位符，父组件传递进来的内容就会渲染在这里。
