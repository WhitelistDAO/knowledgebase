## EscapeOfGolang
### 关于golang逃逸分析的解释：
#### 堆，栈， 解释：
栈：在程序中，每个函数块会有着自己的一块区域来存储局部变量，返回地址，返回值之类的数据这一块内存区域有着特定的结构和寻址方式，大小在编译的时候就已经确定，寻址快，开销少。这种内存块我们称其为栈，栈是线程级别的，在创建的时候就已经确定。
堆：程序中，我们还有全局变量，这种类型占用空间较大，而发生逃逸的局部变量也会放到此地，堆没有特定的结构和大小，他动态的根据需求进行调整，所以说，当我们有大量的数据需要存储的时候我们会放在堆里面进行存储，开销会很大。
逃逸分析：决定一个变量是放在堆上还是栈上；而它最基本的原则表示我们的函数如果放回的是局部变量，此变量就会发生逃逸。
学习过c/c++的同学应该知道malloc和new函数，它可以在堆上进行分配一块空间，但是当我们使用了后我们还必须释放，不然会造成内存泄露、所以c++/c中有个很大的坑：当我们在函数内部申明了一个变量，然后返回该变量的指针，因为我们局部变量是声明在栈上的，当我们程序执行完毕时，我们会将栈进行销毁，这意味着我们所有的东西都没了，现在我们又需要返回销毁变量的引用，这将导致程序的崩溃。下面看一个程序：

```
int* f1(void){
  int a = 3;
  return &a;
}
```
这段程序便如上面所说，我们会发生崩溃，但是大家也知道如何去避免这个坑，比如我new一个变量就可以了，因为new函数会直接分配在堆上吧，但是你new的这个变量何时进行清除呢？堆不会像栈那样实行自动回收功能，一切需要靠程序员去解决这些事，所以这变得很麻烦。
逃逸分析会把变量放在改放在的地方，即便我们new一个变量出来，但是发现在其他地方未被使用我们还是会放在栈上的，因为栈是比堆的分配快得多的，栈分配只会有两个命令：push和release，分配和释放，但是如果我们将所有变量都放在堆上，这是十分慢的，因为我们堆分配需要首先去找一块大小合适的内存块，并且用完之后还需要垃圾回收（gc）才能释放，并且垃圾回收十分的占用cpu（25%）。通过逃逸分析我们可以把那些不必要的变量放在栈上，进而减小堆的开销，同时减少gc压力，提高运行效率。
我们可以通过go的命令查看是否发生了逃逸分析
```
package main
func main(){
  x:=f1
  fmt.Println(*x)
}
func f1() *int{
  t:=1
  return &t
}
```
可以看到我们的t逃逸到了heap上面，因为我们在主函数上面使用了t变量。但是另一点是x也发生了逃逸，这是因为我们的fmt.println接收的是一个interface类型，并未确定某一个值类型，所以发生了逃逸。
```
package main
type s struct{
  m *int
}
func main(){
  var x int
  ffff(x)
}
func ffff(y int)(z s){
  z.m=&y
  return z
}
```
我们可以看到y发生了逃逸，因为我们对y进行了引用。